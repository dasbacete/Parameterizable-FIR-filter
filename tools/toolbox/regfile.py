from pathlib import Path

class regfile:
	base_addr = None
	regs = None
	
	def __init__ (self, metadata):
			self.regs = []
			if ('base_addr') in metadata:
				self.base_addr = metadata['base_addr']
			if ('regs') in metadata:
				for reg in metadata['regs']:
					self.regs.append(register(reg, metadata['regs'][reg]))
	
	def dump_if (self, path):
		regif = open(path / 'regif.sv', 'w')
		regif.write("\n/* Register interface definition. This file is autogeneated. */\n\n\n");
		# dump typedefs
		for i in range(len(self.regs)):
			reg = self.regs[i]
			regif.write(f"// {reg.name} register definition \n")
			regif.write(f"`define { (reg.name + '_addr').upper() } 'h{ self.base_addr } + { i*4 }\n")
			regif.write(f"typedef struct packed {{\n");
			for f in reg.fields:
				single = True
				f_len = reg.fields[f]
				if (f_len != 1):
					single = False
				if (single):
					regif.write(f"	logic {f};\n");
				else:
					regif.write(f"	logic [{f_len}:0] {f};\n")
			regif.write(f"}} {reg.name};\n\n")
		# dump interface
		regif.write("interface regif;\n\n")
		for reg in self.regs:
			if reg != self.regs[-1]:
				regif.write(f"	{reg.name} {reg.name}_p;\n")
			else:
				regif.write(f"	{reg.name} {reg.name}_p;\n\n")	
		regif.write("	modport port (\n")
		last = self.regs[-1]
		for reg in self.regs:
			port = "output"
			if 'w' in reg.mode:
				port = "input"
			comma = ','
			if (reg == last):
				comma = ''
			regif.write(f"  	{port} {reg.name}_p{comma}\n")
		regif.write("	);\n\n")
		regif.write("endinterface")
		regif.close()

	def dump_regs(self, path):
		regif = open(path / 'ctrl_regs.sv', 'w')
		regif.write("\n/*  APB control register module. This file is autogenerated. */\n\n");
		regif.write(f"module regfile #(\n\
	parameter dsize = 32,\n\
	parameter asize = 10,\n\
	parameter BASE_ADDR = {self.base_addr}\n\
) (\n\
  input logic clk,\n\
  input logic rst,\n\
  apbif.consumer apb,\n\
  regif.port  regs\n\
);\n\
  localparam bytes = dsize/8;\n\
  localparam max_addr = int'($pow(2,asize));\n\
  assign apb.PREADY = apb.PENABLE;\n\
  logic [asize-3:0][bytes-1:0][7:0] ctrl_r;\n\
  logic [bytes-1:0][7:0] in_data, out_data;\n\n\
  generate\n\
    for (genvar i = 0; i < bytes; i++) begin\n\
      assign in_data[i] = apb.PWDATA[(i+1)*8-1:i*8];\n\
      assign apb.PRDATA[(i+1)*8-1:i*8] = out_data[i];\n\
    end \n\
  endgenerate\n\n\
  always_ff @( posedge clk ) begin : APB_WRITE\n\
    if (rst) begin\n")
		for i in range(len(self.regs)):
			reg = self.regs[i]
			if ("w" in reg.mode):
				regif.write(f"     	 ctrl_r[{i}] <= '0;\n");
		regif.write("end else begin\n\
      if (apb.PSELx) begin\n\
        if (apb.PWRITE) begin\n\
          if (apb.PENABLE) begin\n\
            for( int i = 0; i < bytes; i++ ) begin\n\
              if (apb.PSTRB[i]) begin\n\
                case (apb.PADDR[asize-1:2])\n")
		for i in range(len(self.regs)):
			reg = self.regs[i]
			if ("w" in reg.mode):
				regif.write(f"                	{i} : ctrl_r[{i}][i] <= in_data[i];\n")
		regif.write("                endcase\n\
              end\n\
            end\n\
          end\n\
        end \n\
      end \n\
    end \n\
  end\n\n\
  always_comb begin : APB_READ\n\
    apb.PRDATA = 'hX;\n\
    if (apb.PSELx) begin\n\
      if (!apb.PWRITE) begin\n\
        if (apb.PENABLE) begin\n\
          case (apb.PADDR[asize-1:2])\n")
		for i in range(len(self.regs)):
			reg = self.regs[i]
			if ("r" in reg.mode):
				regif.write(f"            {i} : out_data <= ctrl_r[{i}];\n")
		regif.write("            default : out_data <= 32'hDEADBEEF;\n\
          endcase\n\
        end\n\
      end\n\
    end\n\
  end\n\n")
		for i in range(len(self.regs)):
			reg = self.regs[i]
			dest = f"regs.{reg.name}_p"
			source = f"ctrl_r[{i}]"
			if ("w" in reg.mode):
				aux = source
				source = dest
				dest = aux
			string = f"  assign {source} = {dest};\n"
			regif.write(string)
		regif.write("\nendmodule")
		regif.close()
	
class register:
	name = None
	size = None
	mode = None
	fields = {}
	
	def __init__ (self, name, metadata):
		self.name = name
		self.mode = metadata['mode']
		self.fields = metadata['fields']
		self.size = 0
		for field in metadata['fields']:
			self.size += metadata['fields'][field]
	def __eq__(self, other):
		if (not isinstance(other, register)):
			return NotImplemented
		return self.name == other.name and self.size == other.size and self.mode == other.mode
			
